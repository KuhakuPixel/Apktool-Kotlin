/*
 * This Kotlin source file was generated by the Gradle "init" task.
 */
package apktool.kotlin.lib

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import java.io.File

class ApktoolTest {
    //
    var classLoader = javaClass.classLoader

    // https://stackoverflow.com/a/43415602/14073678
    val testApkPathStr = classLoader.getResource("app-debug.apk")!!.file
    val APK_SMALI_FOLDER_COUNT = 10

    @Test
    fun testDecompile() {
        Apktool(
                apkFile = testApkPathStr,
                decodeResource = true,
        ).use {
            // have manifest
            assertTrue(it.manifestFile.exists())
            assertTrue(it.manifestFile.readText().contains("<uses-permission android:name=\"com.android.vending.BILLING\"/>"))
            // have res folder, but shouldn't have resources.arsc (the compiled resource in binary form https://stackoverflow.com/a/30768318/14073678)
            // because apktool should decode the resource
            assertTrue(it.resourceFolder.exists())
            assertFalse(it.resourceArscFile.exists())
        }
    }

    @Test
    fun `testDecompile decodeResource=false`() {
        Apktool(
                apkFile = testApkPathStr,
                decodeResource = false,
        ).use {
            // have some manifest
            assertTrue(it.manifestFile.exists())
            // have res folder but have resources.arsc
            assertTrue(it.resourceFolder.exists())
            assertTrue(it.resourceArscFile.exists())

        }
    }

    @Test
    fun `test decompile, patch and recompile`() {
        // test replacing <uses-permission android:name="com.android.vending.BILLING"/> permission with
        // <uses-permission android:name="android.permission.INTERNET"/>
        val textInManifestToRemove = "<uses-permission android:name=\"com.android.vending.BILLING\"/>"
        val textInManifestToBeAdded = "<uses-permission android:name=\"android.permission.INTERNET\"/>"

        Apktool(

                apkFile = testApkPathStr,
                decodeResource = true,
        ).use { apktool ->
            assertTrue(apktool.manifestFile.readText().contains(textInManifestToRemove))
            assertFalse(apktool.manifestFile.readText().contains(textInManifestToBeAdded))
            // replace and write back to the manifest
            val newManifestContent = apktool.manifestFile.readText().replace(textInManifestToRemove, textInManifestToBeAdded)
            apktool.manifestFile.printWriter().use { out ->
                out.print(newManifestContent)
            }
            // export in temp dir and check assert [textInManifestToRemove] is removed
            TempDirectory().use { tempDir ->
                val exportedApkPath: File = File(tempDir.directory.toString(), "exported.apk")
                apktool.export(exportedApkPath, signApk = true)
                // decompile the apk again and read the manifest
                // to make sure the permission has been replaced
                Apktool(apkFile = exportedApkPath.toString(), decodeResource = true).use { apktool2 ->
                    assertFalse(apktool2.manifestFile.readText().contains(textInManifestToRemove))
                    assertTrue(apktool2.manifestFile.readText().contains(textInManifestToBeAdded))

                }
            }


        }
    }

    @Test
    fun `testDecompile with custom decompilation path`() {
        TempDirectory().use { tempDir ->

            Apktool(
                    apkFile = testApkPathStr,
                    decodeResource = false,
                    decompilationFolder = tempDir.directory
            ).use {
                // check if its decompiled in the directory that we specify
                // by checking the existence of AndroidManifest.xml at the root of [tempDir] directory
                val manifestFile = File(tempDir.directory.toString(), "AndroidManifest.xml")
                assertTrue(manifestFile.exists())

            }


        }
    }

    @Test
    fun `test injectPermissionName, decodeResource = true`() {

        val permissionToAdd = "<uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\"/>"
        Apktool(
                apkFile = testApkPathStr,
                decodeResource = true,
        ).use {
            val originalContent = it.manifestFile.readLines()

            assertFalse(originalContent.contains(permissionToAdd))
            it.injectPermissionName("android.permission.QUERY_ALL_PACKAGES")

            val newContent = it.manifestFile.readLines()
            assertTrue(newContent.contains(permissionToAdd))
        }

    }

    @Test
    fun `test injectPermissionName, decodeResource = false`() {

        val permissionToAdd = "<uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\"/>"
        Apktool(
                apkFile = testApkPathStr,
                decodeResource = false,
        ).use {
            val originalContent = it.manifestFile.readLines()

            assertFalse(originalContent.contains(permissionToAdd))
            // needs to throw exception when we don't decodeResource
            // when trying to inject permission
            try {
                it.injectPermissionName("android.permission.QUERY_ALL_PACKAGES")
                assert(false)
            } catch (e: IllegalStateException) {
                assert(true)

            }
        }

    }

    @Test
    fun `TestIterateSmaliClassesFolder`() {
        val expectedSmaliFolder: MutableList<String> = mutableListOf()

        for (i in 0 until APK_SMALI_FOLDER_COUNT) {
            if (i == 0)
                expectedSmaliFolder.add("smali")
            else
                expectedSmaliFolder.add("smali_classes${i + 1}")
        }

        val iteratedSmaliFolder: MutableList<String> = mutableListOf()
        Apktool(
                apkFile = testApkPathStr,
                decodeResource = false,
        ).use {
            it.IterateSmaliClassesFolder {
                iteratedSmaliFolder.add(it.name)
            }
        }
        // sort to make sure
        assertEquals(expectedSmaliFolder.sorted(), iteratedSmaliFolder.sorted())

    }

    @Test
    fun `TestGetSmaliClassesCount`() {
        Apktool(
                apkFile = testApkPathStr,
                decodeResource = false,
        ).use {
            assertEquals(APK_SMALI_FOLDER_COUNT, it.GetSmaliClassesCount())

        }

    }
}
