/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package apktool.kotlin.app


import apktool.kotlin.lib.Apktool
import kotlinx.cli.ArgParser
import kotlinx.cli.ArgType
import kotlinx.cli.default
import kotlinx.cli.required
import java.io.File
import java.lang.RuntimeException

fun main(args: Array<String>) {
    // arg parsing
    val parser = ArgParser("patcher :)")
    val input by parser.option(ArgType.String, shortName = "i", description = "Input file").required()
    val redirectToLuckyPatcher by parser.option(ArgType.Boolean, shortName = "lp", description = "redirect to lucky patcher").default(false)
    parser.parse(args)
    //

    // replace the string
    val originalPackageName = "\"com.android.vending\""
    var newPackageName = ""

    val originalServiceToConnectToName = "\"com.android.vending.billing.InAppBillingService.BIND\""
    var newServiceToConnectToName = ""

    if (redirectToLuckyPatcher) {
        println("redirecting purchases to lucky patcher")
        newPackageName = "\"com.android.vending.billing.InAppBillingService.BINN\""
        newServiceToConnectToName = "\"com.android.vending.billing.InAppBillingService.BINN\""
    } else {
        println("redirecting purchases to own service")
        // redirect to our own
        newPackageName = "\"org.billinghack\""
        newServiceToConnectToName = "\"org.billinghack.BillingService.BIND\""

    }

    // =========================================== begin patch =============================
    Apktool(
            apkFile = input,
            decodeResource = true,
            cleanDecompilationFolder = true
    ).use {
        val decompiledFiles: Array<File> = it.decompilationFolder!!.listFiles()!!

        for (f: File in decompiledFiles) {
            println(f.absolutePath)
        }
        // ============== begin the patch process ================
        // make sure we found billing client library
        var containsPatch = false
        it.IterateSmaliClassesFolder {
            val currentFolder = File(it.toString(), "com/android/billingclient/api/")
            // make sure folder  exist
            if (currentFolder.exists()){
                val billingClientFiles: Array<File> = currentFolder!!.listFiles()!!
                // for folder, find the exact and replace
                for (f in billingClientFiles) {
                    // write
                    val text: String = f.readText()
                    var newText = text.replace(originalPackageName, newPackageName)
                    newText = newText.replace(originalServiceToConnectToName, newServiceToConnectToName)
                    // write back changes when succsess
                    if (text!=newText){
                        println("writing to ${f.absolutePath}")
                        containsPatch = true
                        f.printWriter().use { out ->
                            out.print(newText)
                        }
                    }
                }
            }
        }
        if (!containsPatch){
            throw RuntimeException("nothing is patched :(")
        }

        println("injecting permission")
        // inject permission for querying other package's services
        it.injectPermissionName("android.permission.QUERY_ALL_PACKAGES")
        //
        it.export("Recompiled.apk", signApk = true)
    }


}
