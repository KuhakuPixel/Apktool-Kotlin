/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package apktool.kotlin.app


import apktool.kotlin.lib.Apktool
import kotlinx.cli.ArgParser
import kotlinx.cli.ArgType
import kotlinx.cli.default
import kotlinx.cli.required
import java.io.File
import java.lang.RuntimeException


val ORIGINAL_BILLING_CLIENT_FOLDER_PATH = "com/android/billingclient/api/"

fun patchStringContent(content: String, redirectToLuckyPatcher:Boolean = false): String {
    // replace the string
    val originalPackageName = "\"com.android.vending\""
    var newPackageName = ""

    val originalServiceToConnectToName = "\"com.android.vending.billing.InAppBillingService.BIND\""
    var newServiceToConnectToName = ""
    if (redirectToLuckyPatcher) {
        println("redirecting purchases to lucky patcher")
        newPackageName = "\"com.android.vending.billing.InAppBillingService.BINN\""
        newServiceToConnectToName = "\"com.android.vending.billing.InAppBillingService.BINN\""
    } else {
        println("redirecting purchases to own service")
        // redirect to our own
        newPackageName = "\"org.billinghack\""
        newServiceToConnectToName = "\"org.billinghack.BillingService.BIND\""

    }

    if (content.contains)

    var newText = text.replace(originalPackageName, newPackageName)
    newText = newText.replace(originalServiceToConnectToName, newServiceToConnectToName)
}

fun main(args: Array<String>) {
    // arg parsing
    val parser = ArgParser("patcher :)")
    val inputFile by parser.option(ArgType.String, shortName = "i", description = "Input file").required()
    val redirectToLuckyPatcher by parser.option(ArgType.Boolean, shortName = "lp", description = "redirect to lucky patcher").default(false)
    parser.parse(args)
    //


    if (redirectToLuckyPatcher) {
        println("redirecting purchases to lucky patcher")
        newPackageName = "\"com.android.vending.billing.InAppBillingService.BINN\""
        newServiceToConnectToName = "\"com.android.vending.billing.InAppBillingService.BINN\""
    } else {
        println("redirecting purchases to own service")
        // redirect to our own
        newPackageName = "\"org.billinghack\""
        newServiceToConnectToName = "\"org.billinghack.BillingService.BIND\""

    }

    // =========================================== begin patch =============================
    Apktool(
            apkFile = inputFile,
            decodeResource = true,
            cleanDecompilationFolder = true
    ).use {
        val decompiledFiles: Array<File> = it.decompilationFolder!!.listFiles()!!

        for (f: File in decompiledFiles) {
            println(f.absolutePath)
        }
        // ============== begin the patch process ================
        // make sure we found billing client library
        var containsPatch = false
        it.IterateSmaliClassesFolder {
            
            val currentFolder = File(it.toString(), ORIGINAL_BILLING_CLIENT_FOLDER_PATH)
            // make sure folder  exist
            if (currentFolder.exists()){
                val billingClientFiles: Array<File> = currentFolder!!.listFiles()!!
                // for folder, find the exact and replace
                for (f in billingClientFiles) {
                    // write
                    val text: String = f.readText()
                    var newText = patchStringContent(text, redirectToLuckyPatcher)
                    // write back changes when succsess
                    if (text!=newText){
                        println("writing to ${f.absolutePath}")
                        containsPatch = true
                        f.printWriter().use { out ->
                            out.print(newText)
                        }
                    }
                }
            }
        }

        if (!containsPatch){
            File("/tmp").walkTopDown().forEach { println(it) }
            println("${ORIGINAL_BILLING_CLIENT_FOLDER_PATH} not found, probably obfuscated, trying to find the file")

            it.IterateSmaliClassesFolder {
                File(it.toString()).walkTopDown().forEach { 
                    println(checking: ${it.toString()}) 
                    // write
                    val text: String = f.readText()
                    var newText = patchStringContent(text, redirectToLuckyPatcher)
                    // write back changes when succsess
                    if (text!=newText){
                        println("writing to ${f.absolutePath}")
                        containsPatch = true
                        f.printWriter().use { out ->
                            out.print(newText)
                        }
                    }
                }
                
                val currentFolder = File(it.toString(), ORIGINAL_BILLING_CLIENT_FOLDER_PATH)
                // make sure folder  exist
                if (currentFolder.exists()){
                    val billingClientFiles: Array<File> = currentFolder!!.listFiles()!!
                    // for folder, find the exact and replace
                    for (f in billingClientFiles) {
                    }
                }
            }"/tmp"
        }

        println("injecting permission")
        // inject permission for querying other package's services
        it.injectPermissionName("android.permission.QUERY_ALL_PACKAGES")
        //
        it.export("Recompiled.apk", signApk = true)
    }


}
